#include <cmath>
#include <ctime>
#include <libtensor/core/allocator.h>
#include <libtensor/dense_tensor/dense_tensor.h>
#include <libtensor/dense_tensor/dense_tensor_ctrl.h>
#include <libtensor/dense_tensor/to_diag.h>
#include "../compare_ref.h"
#include "to_diag_test.h"

namespace libtensor {

void to_diag_test::perform() throw(libtest::test_exception) {
    std::cout << "Testing to_diag_test_x<double>  ";
    to_diag_test_x<double> t_double;
    t_double.perform();
    std::cout << "Testing to_diag_test_x<float>  ";
    to_diag_test_x<float> t_float;
    t_float.perform();
}

template<>
const double to_diag_test_x<double>::k_thresh = 7e-14;

template<>
const float to_diag_test_x<float>::k_thresh = 1e-5;

template<typename T>
void to_diag_test_x<T>::perform() throw(libtest::test_exception) {

    srand48(time(0));

    test_1();
    test_2();
    test_3();
    test_4();
    test_5();
    test_6();
    test_7();
    test_8();
    test_9();
}


/** \test Extract a single diagonal: \f$ b_i = a_{ii} \f$
 **/
template<typename T>
void to_diag_test_x<T>::test_1() throw(libtest::test_exception) {

    static const char *testname = "to_diag_test_x<T>::test_1()";

    typedef allocator<T> allocator;

    try {

    index<1> i1a, i1b;
    i1b[0] = 10;
    index<2> i2a, i2b;
    i2b[0] = 10; i2b[1] = 10;
    dimensions<1> dims1(index_range<1>(i1a, i1b));
    dimensions<2> dims2(index_range<2>(i2a, i2b));
    size_t sza = dims2.get_size(), szb = dims1.get_size();

    dense_tensor<2, T, allocator> ta(dims2);
    dense_tensor<1, T, allocator> tb(dims1), tb_ref(dims1);

    {
    dense_tensor_ctrl<2, T> tca(ta);
    dense_tensor_ctrl<1, T> tcb(tb), tcb_ref(tb_ref);

    T *pa = tca.req_dataptr();
    T *pb = tcb.req_dataptr();
    T *pb_ref = tcb_ref.req_dataptr();

    for(size_t i = 0; i < sza; i++) pa[i] = drand48();
    for(size_t i = 0; i < szb; i++) pb[i] = drand48();

    for(size_t i = 0; i < szb; i++) {
        index<2> idxa; idxa[0] = i; idxa[1] = i;
        index<1> idxb; idxb[0] = i;
        abs_index<2> aidxa(idxa, dims2);
        abs_index<1> aidxb(idxb, dims1);
        pb_ref[aidxb.get_abs_index()] = pa[aidxa.get_abs_index()];
    }

    tca.ret_dataptr(pa); pa = 0;
    tcb.ret_dataptr(pb); pb = 0;
    tcb_ref.ret_dataptr(pb_ref); pb_ref = 0;
    }

    sequence<2, size_t> m; m[0] = 1; m[1] = 1;
    to_diag<2, 1, T>(ta, m).perform(true, tb);

    compare_ref_x<1, T>::compare(testname, tb, tb_ref, k_thresh);

    } catch(exception &e) {
        fail_test(testname, __FILE__, __LINE__, e.what());
    }
}


/** \test Extract a single diagonal with one index intact:
        \f$ b_{ij} = a_{iij} \f$
 **/
template<typename T>
void to_diag_test_x<T>::test_2() throw(libtest::test_exception) {

    static const char *testname = "to_diag_test_x<T>::test_2()";

    typedef allocator<T> allocator;

    try {

    size_t ni = 6, nj = 11;
    index<2> i2a, i2b;
    i2b[0] = ni - 1; i2b[1] = nj - 1;
    index<3> i3a, i3b;
    i3b[0] = ni - 1; i3b[1] = ni - 1; i3b[2] = nj - 1;
    dimensions<2> dims2(index_range<2>(i2a, i2b));
    dimensions<3> dims3(index_range<3>(i3a, i3b));
    size_t sza = dims3.get_size(), szb = dims2.get_size();

    dense_tensor<3, T, allocator> ta(dims3);
    dense_tensor<2, T, allocator> tb(dims2), tb_ref(dims2);

    {
    dense_tensor_ctrl<3, T> tca(ta);
    dense_tensor_ctrl<2, T> tcb(tb), tcb_ref(tb_ref);

    T *pa = tca.req_dataptr();
    T *pb = tcb.req_dataptr();
    T *pb_ref = tcb_ref.req_dataptr();

    for(size_t i = 0; i < sza; i++) pa[i] = drand48();
    for(size_t i = 0; i < szb; i++) pb[i] = drand48();

    for(size_t i = 0; i < ni; i++) {
    for(size_t j = 0; j < nj; j++) {
        index<3> idxa; idxa[0] = i; idxa[1] = i; idxa[2] = j;
        index<2> idxb; idxb[0] = i; idxb[1] = j;
        abs_index<3> aidxa(idxa, dims3);
        abs_index<2> aidxb(idxb, dims2);
        pb_ref[aidxb.get_abs_index()] = pa[aidxa.get_abs_index()];
    }
    }

    tca.ret_dataptr(pa); pa = 0;
    tcb.ret_dataptr(pb); pb = 0;
    tcb_ref.ret_dataptr(pb_ref); pb_ref = 0;
    }

    sequence<3, size_t> m; m[0] = 1; m[1] = 1; m[2] = 0;
    to_diag<3, 2, T>(ta, m).perform(true, tb);

    compare_ref_x<2, T>::compare(testname, tb, tb_ref, k_thresh);

    } catch(exception &e) {
        fail_test(testname, __FILE__, __LINE__, e.what());
    }
}


/** \test Extract a single diagonal with one index intact:
        \f$ b_{ij} = a_{iji} \f$
 **/
template<typename T>
void to_diag_test_x<T>::test_3() throw(libtest::test_exception) {

    static const char *testname = "to_diag_test_x<T>::test_3()";

    typedef allocator<T> allocator;

    try {

    size_t ni = 6, nj = 11;
    index<2> i2a, i2b;
    i2b[0] = ni - 1; i2b[1] = nj - 1;
    index<3> i3a, i3b;
    i3b[0] = ni - 1; i3b[1] = nj - 1; i3b[2] = ni - 1;
    dimensions<2> dims2(index_range<2>(i2a, i2b));
    dimensions<3> dims3(index_range<3>(i3a, i3b));
    size_t sza = dims3.get_size(), szb = dims2.get_size();

    dense_tensor<3, T, allocator> ta(dims3);
    dense_tensor<2, T, allocator> tb(dims2), tb_ref(dims2);

    {
    dense_tensor_ctrl<3, T> tca(ta);
    dense_tensor_ctrl<2, T> tcb(tb), tcb_ref(tb_ref);

    T *pa = tca.req_dataptr();
    T *pb = tcb.req_dataptr();
    T *pb_ref = tcb_ref.req_dataptr();

    for(size_t i = 0; i < sza; i++) pa[i] = drand48();
    for(size_t i = 0; i < szb; i++) pb[i] = drand48();

    for(size_t i = 0; i < ni; i++) {
    for(size_t j = 0; j < nj; j++) {
        index<3> idxa; idxa[0] = i; idxa[1] = j; idxa[2] = i;
        index<2> idxb; idxb[0] = i; idxb[1] = j;
        abs_index<3> aidxa(idxa, dims3);
        abs_index<2> aidxb(idxb, dims2);
        pb_ref[aidxb.get_abs_index()] = pa[aidxa.get_abs_index()];
    }
    }

    tca.ret_dataptr(pa); pa = 0;
    tcb.ret_dataptr(pb); pb = 0;
    tcb_ref.ret_dataptr(pb_ref); pb_ref = 0;
    }

    sequence<3, size_t> m; m[0] = 1; m[1] = 0; m[2] = 1;
    to_diag<3, 2, T>(ta, m).perform(true, tb);

    compare_ref_x<2, T>::compare(testname, tb, tb_ref, k_thresh);

    } catch(exception &e) {
        fail_test(testname, __FILE__, __LINE__, e.what());
    }
}


/** \test Extract a single diagonal with one index intact:
        \f$ b_{ji} = a_{jii} \f$
 **/
template<typename T>
void to_diag_test_x<T>::test_4() throw(libtest::test_exception) {

    static const char *testname = "to_diag_test_x<T>::test_4()";

    typedef allocator<T> allocator;

    try {

    size_t ni = 6, nj = 11;
    index<2> i2a, i2b;
    i2b[0] = nj - 1; i2b[1] = ni - 1;
    index<3> i3a, i3b;
    i3b[0] = nj - 1; i3b[1] = ni - 1; i3b[2] = ni - 1;
    dimensions<2> dims2(index_range<2>(i2a, i2b));
    dimensions<3> dims3(index_range<3>(i3a, i3b));
    size_t sza = dims3.get_size(), szb = dims2.get_size();

    dense_tensor<3, T, allocator> ta(dims3);
    dense_tensor<2, T, allocator> tb(dims2), tb_ref(dims2);

    {
    dense_tensor_ctrl<3, T> tca(ta);
    dense_tensor_ctrl<2, T> tcb(tb), tcb_ref(tb_ref);

    T *pa = tca.req_dataptr();
    T *pb = tcb.req_dataptr();
    T *pb_ref = tcb_ref.req_dataptr();

    for(size_t i = 0; i < sza; i++) pa[i] = drand48();
    for(size_t i = 0; i < szb; i++) pb[i] = drand48();

    for(size_t i = 0; i < ni; i++) {
    for(size_t j = 0; j < nj; j++) {
        index<3> idxa; idxa[0] = j; idxa[1] = i; idxa[2] = i;
        index<2> idxb; idxb[0] = j; idxb[1] = i;
        abs_index<3> aidxa(idxa, dims3);
        abs_index<2> aidxb(idxb, dims2);
        pb_ref[aidxb.get_abs_index()] = pa[aidxa.get_abs_index()];
    }
    }

    tca.ret_dataptr(pa); pa = 0;
    tcb.ret_dataptr(pb); pb = 0;
    tcb_ref.ret_dataptr(pb_ref); pb_ref = 0;
    }

    sequence<3, size_t> m; m[0] = 0; m[1] = 1; m[2] = 1;
    to_diag<3, 2, T>(ta, m).perform(true, tb);

    compare_ref_x<2, T>::compare(testname, tb, tb_ref, k_thresh);

    } catch(exception &e) {
        fail_test(testname, __FILE__, __LINE__, e.what());
    }
}


/** \test Extract a single diagonal with one index intact and permuted:
        output \f$ b_{ij} = a_{jii} \f$
 **/
template<typename T>
void to_diag_test_x<T>::test_5() throw(libtest::test_exception) {

    static const char *testname = "to_diag_test_x<T>::test_5()";

    typedef allocator<T> allocator;

    try {

    size_t ni = 6, nj = 11;
    index<2> i2a, i2b;
    i2b[0] = ni - 1; i2b[1] = nj - 1;
    index<3> i3a, i3b;
    i3b[0] = nj - 1; i3b[1] = ni - 1; i3b[2] = ni - 1;
    dimensions<2> dims2(index_range<2>(i2a, i2b));
    dimensions<3> dims3(index_range<3>(i3a, i3b));
    size_t sza = dims3.get_size(), szb = dims2.get_size();

    dense_tensor<3, T, allocator> ta(dims3);
    dense_tensor<2, T, allocator> tb(dims2), tb_ref(dims2);

    {
    dense_tensor_ctrl<3, T> tca(ta);
    dense_tensor_ctrl<2, T> tcb(tb), tcb_ref(tb_ref);

    T *pa = tca.req_dataptr();
    T *pb = tcb.req_dataptr();
    T *pb_ref = tcb_ref.req_dataptr();

    for(size_t i = 0; i < sza; i++) pa[i] = drand48();
    for(size_t i = 0; i < szb; i++) pb[i] = drand48();

    for(size_t i = 0; i < ni; i++) {
    for(size_t j = 0; j < nj; j++) {
        index<3> idxa; idxa[0] = j; idxa[1] = i; idxa[2] = i;
        index<2> idxb; idxb[0] = i; idxb[1] = j;
        abs_index<3> aidxa(idxa, dims3);
        abs_index<2> aidxb(idxb, dims2);
        pb_ref[aidxb.get_abs_index()] = pa[aidxa.get_abs_index()];
    }
    }

    tca.ret_dataptr(pa); pa = 0;
    tcb.ret_dataptr(pb); pb = 0;
    tcb_ref.ret_dataptr(pb_ref); pb_ref = 0;
    }

    sequence<3, size_t> m; m[0] = 0; m[1] = 1; m[2] = 1;
    permutation<2> permb; permb.permute(0, 1);
    tensor_transf<2, T> tr(permb);
    to_diag<3, 2, T>(ta, m, tr).perform(true, tb);

    compare_ref_x<2, T>::compare(testname, tb, tb_ref, k_thresh);

    } catch(exception &e) {
        fail_test(testname, __FILE__, __LINE__, e.what());
    }
}

/** \test Extract a single diagonal with one index intact and permuted:
        output \f$ b_{jik} = a_{ikjk} \f$
 **/
template<typename T>
void to_diag_test_x<T>::test_6() throw(libtest::test_exception) {

    static const char *testname = "to_diag_test_x<T>::test_6()";

    typedef allocator<T> allocator;

    try {

    size_t ni = 2, nj = 3, nk = 5;
    index<3> i3a, i3b;
    i3b[0] = nj - 1; i3b[1] = ni - 1; i3b[2] = nk - 1;
    index<4> i4a, i4b;
    i4b[0] = ni - 1; i4b[1] = nk - 1; i4b[2] = nj - 1; i4b[3] = nk - 1;
    dimensions<3> dims3(index_range<3>(i3a, i3b));
    dimensions<4> dims4(index_range<4>(i4a, i4b));
    size_t sza = dims4.get_size(), szb = dims3.get_size();

    dense_tensor<4, T, allocator> ta(dims4);
    dense_tensor<3, T, allocator> tb(dims3), tb_ref(dims3);

    {
    dense_tensor_ctrl<4, T> tca(ta);
    dense_tensor_ctrl<3, T> tcb(tb), tcb_ref(tb_ref);

    T *pa = tca.req_dataptr();
    T *pb = tcb.req_dataptr();
    T *pb_ref = tcb_ref.req_dataptr();

    for(size_t i = 0; i < sza; i++) pa[i] = drand48();
    for(size_t i = 0; i < szb; i++) pb[i] = drand48();

    for(size_t i = 0; i < ni; i++) {
    for(size_t j = 0; j < nj; j++) {
    for(size_t k = 0; k < nk; k++) {
        index<4> idxa; idxa[0] = i; idxa[1] = k; idxa[2] = j; idxa[3] = k;
        index<3> idxb; idxb[0] = j; idxb[1] = i; idxb[2] = k;
        abs_index<4> aidxa(idxa, dims4);
        abs_index<3> aidxb(idxb, dims3);
        pb_ref[aidxb.get_abs_index()] = pa[aidxa.get_abs_index()];
    }
    }
    }

    tca.ret_dataptr(pa); pa = 0;
    tcb.ret_dataptr(pb); pb = 0;
    tcb_ref.ret_dataptr(pb_ref); pb_ref = 0;
    }

    sequence<4, size_t> m; m[0] = 0; m[1] = 1; m[2] = 0; m[3] = 1;
    permutation<3> permb; permb.permute(0, 1).permute(0, 2);
    tensor_transf<3, T> tr(permb);
    to_diag<4, 3, T>(ta, m, tr).perform(true, tb);

    compare_ref_x<3, T>::compare(testname, tb, tb_ref, k_thresh);

    } catch(exception &e) {
        fail_test(testname, __FILE__, __LINE__, e.what());
    }
}


/** \test Extract a two diagonals and permute:
        output \f$ b_{ji} = a_{ijij} \f$
 **/
template<typename T>
void to_diag_test_x<T>::test_7() throw(libtest::test_exception) {

    static const char *testname = "to_diag_test_x<T>::test_7()";

    typedef allocator<T> allocator;

    try {

    size_t ni = 2, nj = 3;
    index<2> i2a, i2b;
    i2b[0] = nj - 1; i2b[1] = ni - 1;
    index<4> i4a, i4b;
    i4b[0] = ni - 1; i4b[1] = nj - 1; i4b[2] = ni - 1; i4b[3] = nj - 1;
    dimensions<2> dims2(index_range<2>(i2a, i2b));
    dimensions<4> dims4(index_range<4>(i4a, i4b));
    size_t sza = dims4.get_size(), szb = dims2.get_size();

    dense_tensor<4, T, allocator> ta(dims4);
    dense_tensor<2, T, allocator> tb(dims2), tb_ref(dims2);

    {
    dense_tensor_ctrl<4, T> tca(ta);
    dense_tensor_ctrl<2, T> tcb(tb), tcb_ref(tb_ref);

    T *pa = tca.req_dataptr();
    T *pb = tcb.req_dataptr();
    T *pb_ref = tcb_ref.req_dataptr();

    for(size_t i = 0; i < sza; i++) pa[i] = drand48();
    for(size_t i = 0; i < szb; i++) pb[i] = drand48();

    for(size_t i = 0; i < ni; i++) {
    for(size_t j = 0; j < nj; j++) {
        index<4> idxa; idxa[0] = i; idxa[1] = j; idxa[2] = i; idxa[3] = j;
        index<2> idxb; idxb[0] = j; idxb[1] = i;
        abs_index<4> aidxa(idxa, dims4);
        abs_index<2> aidxb(idxb, dims2);
        pb_ref[aidxb.get_abs_index()] = pa[aidxa.get_abs_index()];
    }
    }

    tca.ret_dataptr(pa); pa = 0;
    tcb.ret_dataptr(pb); pb = 0;
    tcb_ref.ret_dataptr(pb_ref); pb_ref = 0;
    }

    sequence<4, size_t> m; m[0] = 1; m[1] = 2; m[2] = 1; m[3] = 2;
    permutation<2> permb; permb.permute(0, 1);
    tensor_transf<2, T> tr(permb);
    to_diag<4, 2, T>(ta, m, tr).perform(true, tb);

    compare_ref_x<2, T>::compare(testname, tb, tb_ref, k_thresh);

    } catch(exception &e) {
        fail_test(testname, __FILE__, __LINE__, e.what());
    }
}


/** \test Extract a two diagonals with one index intact and permuted:
        output \f$ b_{kji} = a_{ikjiij} \f$
 **/
template<typename T>
void to_diag_test_x<T>::test_8() throw(libtest::test_exception) {

    static const char *testname = "to_diag_test_x<T>::test_8()";

    typedef allocator<T> allocator;

    try {

    size_t ni = 2, nj = 3, nk = 5;
    index<3> i3a, i3b;
    i3b[0] = nk - 1; i3b[1] = nj - 1; i3b[2] = ni - 1;
    index<6> i6a, i6b;
    i6b[0] = ni - 1; i6b[1] = nk - 1; i6b[2] = nj - 1;
    i6b[3] = ni - 1; i6b[4] = ni - 1; i6b[5] = nj - 1;
    dimensions<3> dims3(index_range<3>(i3a, i3b));
    dimensions<6> dims6(index_range<6>(i6a, i6b));
    size_t sza = dims6.get_size(), szb = dims3.get_size();

    dense_tensor<6, T, allocator> ta(dims6);
    dense_tensor<3, T, allocator> tb(dims3), tb_ref(dims3);

    {
    dense_tensor_ctrl<6, T> tca(ta);
    dense_tensor_ctrl<3, T> tcb(tb), tcb_ref(tb_ref);

    T *pa = tca.req_dataptr();
    T *pb = tcb.req_dataptr();
    T *pb_ref = tcb_ref.req_dataptr();

    for(size_t i = 0; i < sza; i++) pa[i] = drand48();
    for(size_t i = 0; i < szb; i++) pb[i] = drand48();

    for(size_t i = 0; i < ni; i++) {
    for(size_t j = 0; j < nj; j++) {
    for(size_t k = 0; k < nk; k++) {
        index<6> idxa;
        idxa[0] = i; idxa[1] = k; idxa[2] = j;
        idxa[3] = i; idxa[4] = i; idxa[5] = j;
        index<3> idxb; idxb[0] = k; idxb[1] = j; idxb[2] = i;
        abs_index<6> aidxa(idxa, dims6);
        abs_index<3> aidxb(idxb, dims3);
        pb_ref[aidxb.get_abs_index()] = pa[aidxa.get_abs_index()];
    }
    }
    }

    tca.ret_dataptr(pa); pa = 0;
    tcb.ret_dataptr(pb); pb = 0;
    tcb_ref.ret_dataptr(pb_ref); pb_ref = 0;
    }

    sequence<6, size_t> m;
    m[0] = 1; m[1] = 0; m[2] = 2; m[3] = 1; m[4] = 1; m[5] = 2;
    permutation<3> permb; permb.permute(0, 1).permute(1, 2);
    tensor_transf<3, T> tr(permb);
    to_diag<6, 3, T>(ta, m, tr).perform(true, tb);

    compare_ref_x<3, T>::compare(testname, tb, tb_ref, k_thresh);

    } catch(exception &e) {
        fail_test(testname, __FILE__, __LINE__, e.what());
    }
}


/** \test Extract two diagonals with one index intact and permuted:
        output \f$ b_{ijk} = a_{kiijj} \f$
 **/
template<typename T>
void to_diag_test_x<T>::test_9() throw(libtest::test_exception) {

    static const char *testname = "to_diag_test_x<T>::test_9()";

    typedef allocator<T> allocator;

    try {

    size_t ni = 2, nj = 3, nk = 5;
    index<3> i3a, i3b;
    i3b[0] = ni - 1; i3b[1] = nj - 1; i3b[2] = nk - 1;
    index<5> i5a, i5b;
    i5b[0] = nk - 1; i5b[1] = ni - 1; i5b[2] = ni - 1;
    i5b[3] = nj - 1; i5b[4] = nj - 1;
    dimensions<3> dims3(index_range<3>(i3a, i3b));
    dimensions<5> dims5(index_range<5>(i5a, i5b));
    size_t sza = dims5.get_size(), szb = dims3.get_size();

    dense_tensor<5, T, allocator> ta(dims5);
    dense_tensor<3, T, allocator> tb(dims3), tb_ref(dims3);

    {
    dense_tensor_ctrl<5, T> tca(ta);
    dense_tensor_ctrl<3, T> tcb(tb), tcb_ref(tb_ref);

    T *pa = tca.req_dataptr();
    T *pb = tcb.req_dataptr();
    T *pb_ref = tcb_ref.req_dataptr();

    for(size_t i = 0; i < sza; i++) pa[i] = drand48();
    for(size_t i = 0; i < szb; i++) pb[i] = drand48();

    for(size_t i = 0; i < ni; i++) {
    for(size_t j = 0; j < nj; j++) {
    for(size_t k = 0; k < nk; k++) {
        index<5> idxa; idxa[0] = k; idxa[1] = i; idxa[2] = i;
        idxa[3] = j; idxa[4] = j;
        index<3> idxb; idxb[0] = i; idxb[1] = j; idxb[2] = k;
        abs_index<5> aidxa(idxa, dims5);
        abs_index<3> aidxb(idxb, dims3);
        pb_ref[aidxb.get_abs_index()] = pa[aidxa.get_abs_index()];
    }
    }
    }

    tca.ret_dataptr(pa); pa = 0;
    tcb.ret_dataptr(pb); pb = 0;
    tcb_ref.ret_dataptr(pb_ref); pb_ref = 0;
    }

    sequence<5, size_t> m; m[0] = 0; m[1] = 1; m[2] = 1; m[3] = 2; m[4] = 2;
    permutation<3> permb; permb.permute(0, 1).permute(1, 2);
    tensor_transf<3, T> tr(permb);
    to_diag<5, 3, T>(ta, m, tr).perform(true, tb);

    compare_ref_x<3, T>::compare(testname, tb, tb_ref, k_thresh);

    } catch(exception &e) {
        fail_test(testname, __FILE__, __LINE__, e.what());
    }
}

template class to_diag_test_x<double>;
template class to_diag_test_x<float>;

} // namespace libtensor
